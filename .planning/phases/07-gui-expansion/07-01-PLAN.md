---
phase: 07-gui-expansion
plan: 01
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: false
---

<objective>
Add revision configuration controls to the Tkinter GUI.

Purpose: Enable users to view and modify per-MID revision limits through the GUI, providing visual feedback and control over the emulator's protocol capabilities.
Output: New "Revision Configuration" LabelFrame in the GUI with per-MID revision spinboxes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-revision-configuration/06-01-PLAN.md
@.planning/phases/06-revision-configuration/06-02-PLAN.md
@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add revision configuration GUI variables</name>
  <files>open_protocol_emulator.py</files>
  <action>
In `start_gui()`, after the existing GUI Variables section (after line ~1274 `# --- End GUI Variables ---`), add new StringVar variables for each configurable MID revision:

```python
# --- Revision Configuration GUI Variables ---
rev_mid_0002_var = tk.StringVar(value=str(self.revision_config.get(2, 6)))
rev_mid_0004_var = tk.StringVar(value=str(self.revision_config.get(4, 3)))
rev_mid_0015_var = tk.StringVar(value=str(self.revision_config.get(15, 2)))
rev_mid_0041_var = tk.StringVar(value=str(self.revision_config.get(41, 5)))
rev_mid_0052_var = tk.StringVar(value=str(self.revision_config.get(52, 2)))
rev_mid_0061_var = tk.StringVar(value=str(self.revision_config.get(61, 7)))
# --- End Revision Configuration GUI Variables ---
```

These variables will be bound to spinbox widgets in Task 2.

IMPORTANT: This task assumes Phase 6 Plan 01 has been executed and `self.revision_config` exists. If it doesn't exist, this plan will fail at runtime.
  </action>
  <verify>Python syntax check: `python -m py_compile open_protocol_emulator.py`</verify>
  <done>Six revision StringVar variables added to start_gui()</done>
</task>

<task type="auto">
  <name>Task 2: Create Revision Configuration LabelFrame with controls</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add a new LabelFrame for revision configuration. Place this after the Pset Settings Frame section (after line ~1451 `# --- End Pset Settings Frame ---`), before the Controls frame:

```python
# --- Revision Configuration Frame ---
revision_frame = tk.LabelFrame(root, text="Revision Configuration", padx=5, pady=5)
revision_frame.pack(padx=10, pady=5, fill=tk.X)

# Row 0: MID 0002 and MID 0004
tk.Label(revision_frame, text="MID 0002 (Comm Start):").grid(row=0, column=0, sticky=tk.W, padx=2, pady=2)
tk.Spinbox(revision_frame, from_=1, to=6, textvariable=rev_mid_0002_var, width=3).grid(row=0, column=1, sticky=tk.W, padx=2, pady=2)
tk.Label(revision_frame, text="MID 0004 (Error):").grid(row=0, column=2, sticky=tk.W, padx=2, pady=2)
tk.Spinbox(revision_frame, from_=1, to=3, textvariable=rev_mid_0004_var, width=3).grid(row=0, column=3, sticky=tk.W, padx=2, pady=2)

# Row 1: MID 0015 and MID 0041
tk.Label(revision_frame, text="MID 0015 (Pset):").grid(row=1, column=0, sticky=tk.W, padx=2, pady=2)
tk.Spinbox(revision_frame, from_=1, to=2, textvariable=rev_mid_0015_var, width=3).grid(row=1, column=1, sticky=tk.W, padx=2, pady=2)
tk.Label(revision_frame, text="MID 0041 (Tool Data):").grid(row=1, column=2, sticky=tk.W, padx=2, pady=2)
tk.Spinbox(revision_frame, from_=1, to=5, textvariable=rev_mid_0041_var, width=3).grid(row=1, column=3, sticky=tk.W, padx=2, pady=2)

# Row 2: MID 0052 and MID 0061
tk.Label(revision_frame, text="MID 0052 (VIN):").grid(row=2, column=0, sticky=tk.W, padx=2, pady=2)
tk.Spinbox(revision_frame, from_=1, to=2, textvariable=rev_mid_0052_var, width=3).grid(row=2, column=1, sticky=tk.W, padx=2, pady=2)
tk.Label(revision_frame, text="MID 0061 (Result):").grid(row=2, column=2, sticky=tk.W, padx=2, pady=2)
tk.Spinbox(revision_frame, from_=1, to=7, textvariable=rev_mid_0061_var, width=3).grid(row=2, column=3, sticky=tk.W, padx=2, pady=2)

# Apply button
tk.Button(revision_frame, text="Apply Revisions", command=apply_revision_settings).grid(row=0, column=4, rowspan=3, padx=10, pady=2, sticky=tk.NS)
# --- End Revision Configuration Frame ---
```

The spinbox `to` values match the maximum revision supported by each MID in the emulator.
  </action>
  <verify>Python syntax check: `python -m py_compile open_protocol_emulator.py`</verify>
  <done>Revision Configuration LabelFrame created with 6 spinboxes and Apply button</done>
</task>

<task type="auto">
  <name>Task 3: Implement apply_revision_settings callback</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add the callback function for the Apply Revisions button. Place this in the GUI Callbacks section (after line ~1406 `# --- End GUI Callbacks ---` - but before that comment, after the other callback functions):

```python
def apply_revision_settings():
    """Apply revision configuration from GUI spinboxes."""
    try:
        self.set_max_revision(2, int(rev_mid_0002_var.get()))
        self.set_max_revision(4, int(rev_mid_0004_var.get()))
        self.set_max_revision(15, int(rev_mid_0015_var.get()))
        self.set_max_revision(41, int(rev_mid_0041_var.get()))
        self.set_max_revision(52, int(rev_mid_0052_var.get()))
        self.set_max_revision(61, int(rev_mid_0061_var.get()))
        self.current_profile = "custom"  # Mark as custom since user modified revisions
        print("[GUI] Applied revision configuration:")
        for mid, rev in sorted(self.revision_config.items()):
            print(f"  MID {mid:04d}: rev {rev}")
    except ValueError as e:
        messagebox.showerror("Error", f"Invalid revision value: {e}")
```

This callback:
- Reads each spinbox value and applies it via set_max_revision() (from Phase 6)
- Sets current_profile to "custom" since user manually modified values
- Logs the applied configuration
  </action>
  <verify>
1. Python syntax check: `python -m py_compile open_protocol_emulator.py`
2. Verify callback exists: search for "def apply_revision_settings" in file
  </verify>
  <done>apply_revision_settings callback implemented using Phase 6 set_max_revision() method</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Revision Configuration GUI panel with 6 MID revision spinboxes and Apply button</what-built>
  <how-to-verify>
    1. Run: `python open_protocol_emulator.py`
    2. Look for new "Revision Configuration" frame between Pset Settings and Controls
    3. Verify 6 labeled spinboxes appear (MID 0002, 0004, 0015, 0041, 0052, 0061)
    4. Try adjusting a spinbox value (e.g., change MID 0061 from 7 to 2)
    5. Click "Apply Revisions" button
    6. Check console output shows applied configuration
    7. Close the GUI (no errors should appear)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile open_protocol_emulator.py` passes
- [ ] Revision Configuration LabelFrame exists with 6 spinboxes
- [ ] apply_revision_settings callback exists and uses set_max_revision()
- [ ] GUI starts without errors
- [ ] Spinbox changes are applied when button is clicked
- [ ] Human verification passed
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Revision configuration visible in GUI
- Changes apply correctly to emulator state
- Human approved the visual layout and functionality
</success_criteria>

<output>
After completion, create `.planning/phases/07-gui-expansion/07-01-SUMMARY.md`
</output>
