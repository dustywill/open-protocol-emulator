---
phase: 03.5-architecture-refactor
plan: 01
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Refactor process_message() from if/elif chain to registry-based MID handler dispatch.

Purpose: Make adding new MIDs cleaner and more maintainable. Current 200-line if/elif chain becomes unwieldy as we add MID 0082, 0100-0102, 0214-0218 in Phase 5.
Output: Registry-based dispatch where each MID has a dedicated handler method, reducing process_message() to ~20 lines.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MID handler registry and base pattern</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add handler registry dictionary and registration pattern in __init__ (after existing state variables):

```python
# --- MID Handler Registry ---
self.mid_handlers = {}
self._register_mid_handlers()
# --- End MID Handler Registry ---
```

Add the registration method after __init__:

```python
def _register_mid_handlers(self):
    """Register all MID handlers in the dispatch registry."""
    self.mid_handlers = {
        1: self._handle_mid_0001,      # Communication start
        3: self._handle_mid_0003,      # Communication stop
        4: self._handle_mid_0004,      # Command error (info)
        5: self._handle_mid_0005,      # Command accepted (info)
        9999: self._handle_mid_9999,   # Keep-alive
        14: self._handle_mid_0014,     # Pset subscribe
        16: self._handle_mid_0016,     # Pset selected ack
        17: self._handle_mid_0017,     # Pset unsubscribe
        18: self._handle_mid_0018,     # Select Pset
        40: self._handle_mid_0040,     # Tool disabled (info)
        41: self._handle_mid_0041,     # Tool enabled (info)
        42: self._handle_mid_0042,     # Disable tool request
        43: self._handle_mid_0043,     # Enable tool request
        50: self._handle_mid_0050,     # VIN download
        51: self._handle_mid_0051,     # VIN subscribe
        53: self._handle_mid_0053,     # VIN ack
        54: self._handle_mid_0054,     # VIN unsubscribe
        60: self._handle_mid_0060,     # Tightening subscribe
        62: self._handle_mid_0062,     # Tightening ack
        63: self._handle_mid_0063,     # Tightening unsubscribe
    }
```

This creates a clean lookup table mapping MID numbers to handler methods.
  </action>
  <verify>Code runs without syntax errors. Registry contains all existing MID handlers.</verify>
  <done>MID handler registry exists and is populated in __init__.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor process_message() to use registry dispatch</name>
  <files>open_protocol_emulator.py</files>
  <action>
Replace the 200-line if/elif chain in process_message() with registry lookup:

```python
def process_message(self, msg: bytes):
    """Parse and dispatch an Open Protocol message."""
    if len(msg) < 21:
        print(f"[Error] Malformed message (too short): {msg}")
        return
    try:
        mid = msg[4:8].decode('ascii')
        rev = msg[8:11].decode('ascii')
        no_ack_flag = msg[11:12].decode('ascii')
        data_field = msg[20:-1].decode('ascii')
        mid_int = int(mid)
    except (ValueError, IndexError, UnicodeDecodeError) as e:
        print(f"[Error] Parse error: {e}, Message: {msg}")
        return

    # --- MID Dispatch via Registry ---
    handler = self.mid_handlers.get(mid_int)
    if handler:
        handler(mid_int, rev, no_ack_flag, data_field, msg)
    else:
        # Unsupported MID
        err_data = f"{mid}{'99'}"
        resp = build_message(4, rev=1, data=err_data)
        self.send_to_client(resp)
        print(f"[Unknown] Received unsupported MID {mid}. Sent error.")
```

This reduces process_message() to ~20 lines. The handler signature is:
`handler(mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes)`

All parsed values are passed to handlers, giving them full context.
  </action>
  <verify>process_message() is under 30 lines. Dispatch works via registry lookup.</verify>
  <done>process_message() uses registry-based dispatch pattern.</done>
</task>

<task type="auto">
  <name>Task 3: Extract communication MID handlers (0001, 0003, 0004, 0005, 9999)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create individual handler methods for communication MIDs. Add after _register_mid_handlers():

```python
# === Communication MID Handlers ===

def _handle_mid_0001(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0001: Communication start."""
    if self.session_active:
        resp = build_message(4, rev=1, data="000196")
    else:
        requested_rev = int(rev) if rev.strip() else 1
        if requested_rev > 1:
            resp = build_message(4, rev=1, data="000197")
        else:
            cell_id = "0001"
            channel_id = "01"
            data = f"01{cell_id}02{channel_id}03{self.controller_name}"
            resp = build_message(2, rev=1, data=data)
            self.session_active = True
            print("[Session] Communication started.")
            threading.Thread(target=self.send_tightening_results_loop, daemon=True).start()
    self.send_to_client(resp)

def _handle_mid_0003(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0003: Communication stop."""
    resp = build_message(5, rev=1, data="0003")
    self.send_to_client(resp)
    print("[Session] Communication stop received. Ending session.")
    self.session_active = False
    self.vin_subscribed = False
    self.result_subscribed = False
    self.pset_subscribed = False
    try:
        if self.client_socket:
            self.client_socket.close()
    except OSError:
        pass
    self.client_socket = None

def _handle_mid_0004(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0004: Command error (info only)."""
    print(f"[Info] Received MID 0004 from client: Data='{data_field}' (ignored).")

def _handle_mid_0005(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0005: Command accepted (info only)."""
    print(f"[Info] Received MID 0005 from client: Data='{data_field}' (ignored).")

def _handle_mid_9999(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 9999: Keep-alive."""
    print("[KeepAlive] Received keep-alive message.")
    resp = build_message(9999, rev=1)
    self.send_to_client(resp)
    print("[KeepAlive] Echo back keep-alive message.")
```
  </action>
  <verify>Communication MIDs work: start session, stop session, keep-alive echoes.</verify>
  <done>Communication MID handlers (0001, 0003, 0004, 0005, 9999) extracted to methods.</done>
</task>

<task type="auto">
  <name>Task 4: Extract tool control MID handlers (0040-0043)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create handler methods for tool control MIDs:

```python
# === Tool Control MID Handlers ===

def _handle_mid_0040(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0040: Disable tool command (controller->client, info only)."""
    print("[Tool] Received Disable Tool Command (MID 0040) from client (unexpected). Ignoring.")

def _handle_mid_0041(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0041: Enable tool command (controller->client, info only)."""
    print("[Tool] Received Enable Tool Command (MID 0041) from client (unexpected). Ignoring.")

def _handle_mid_0042(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0042: Disable tool request."""
    print("[Tool] Received Request Tool Disable (MID 0042).")
    self.tool_enabled = False
    resp = build_message(5, rev=1, data="0042")
    self.send_to_client(resp)
    notification = build_message(40, rev=1)
    self.send_to_client(notification)
    print("[Tool] Tool Disabled. Sent MID 0005 ack and MID 0040 notification.")

def _handle_mid_0043(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0043: Enable tool request."""
    print("[Tool] Received Request Tool Enable (MID 0043).")
    self.tool_enabled = True
    resp = build_message(5, rev=1, data="0043")
    self.send_to_client(resp)
    notification = build_message(41, rev=1)
    self.send_to_client(notification)
    print("[Tool] Tool Enabled. Sent MID 0005 ack and MID 0041 notification.")
```
  </action>
  <verify>Tool disable/enable requests work and send proper notifications.</verify>
  <done>Tool control MID handlers (0040-0043) extracted to methods.</done>
</task>

<task type="auto">
  <name>Task 5: Extract parameter set MID handlers (0014-0018)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create handler methods for parameter set MIDs:

```python
# === Parameter Set MID Handlers ===

def _handle_mid_0014(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0014: Parameter set selected subscribe."""
    if self.pset_subscribed:
        resp = build_message(4, rev=1, data="001406")
    else:
        self.pset_subscribed = True
        resp = build_message(5, rev=1, data="0014")
        print("[Pset] Pset subscription accepted.")
        if self.current_pset:
            mid15_data = self._build_mid15_data()
            mid15_msg = build_message(15, rev=1, data=mid15_data)
            self.send_to_client(mid15_msg)
            print(f"[Pset] Sent current Pset (MID 0015): {self.current_pset}")
    self.send_to_client(resp)

def _handle_mid_0016(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0016: Pset selected acknowledged by client."""
    print("[Pset] Pset selected acknowledged by client (MID 0016).")

def _handle_mid_0017(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0017: Parameter set unsubscribe."""
    if self.pset_subscribed:
        self.pset_subscribed = False
        resp = build_message(5, rev=1, data="0017")
        print("[Pset] Unsubscribed from Pset selection.")
    else:
        resp = build_message(4, rev=1, data="001707")
    self.send_to_client(resp)

def _handle_mid_0018(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0018: Select parameter set."""
    pset_id = data_field.strip()
    if pset_id == "0" or pset_id == "000":
        self.current_pset = "0"
        self.pset_last_change = datetime.datetime.now()
        resp = build_message(5, rev=1, data="0018")
        print("[Pset] No Pset selected (Pset 0).")
        if self.pset_subscribed:
            mid15_data = self._build_mid15_data()
            mid15_msg = build_message(15, rev=1, data=mid15_data)
            self.send_to_client(mid15_msg)
            print("[Pset] Sent MID 0015: Pset 0")
    elif pset_id in self.available_psets:
        self.current_pset = pset_id
        self.pset_last_change = datetime.datetime.now()
        resp = build_message(5, rev=1, data="0018")
        print(f"[Pset] Pset {pset_id} selected.")
        if self.pset_subscribed:
            mid15_data = self._build_mid15_data()
            mid15_msg = build_message(15, rev=1, data=mid15_data)
            self.send_to_client(mid15_msg)
            print(f"[Pset] Sent MID 0015: {self.current_pset}")
    else:
        resp = build_message(4, rev=1, data="001802")
    self.send_to_client(resp)
```
  </action>
  <verify>Pset subscribe/unsubscribe/select work correctly.</verify>
  <done>Parameter set MID handlers (0014-0018) extracted to methods.</done>
</task>

<task type="auto">
  <name>Task 6: Extract VIN MID handlers (0050-0054)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create handler methods for VIN MIDs:

```python
# === VIN MID Handlers ===

def _handle_mid_0050(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0050: VIN download request."""
    vin = data_field.strip()
    print(f"[VIN] Received VIN download: {vin}")
    if self._parse_vin(vin):
        self.current_vin = vin
        with self.state_lock:
            self.batch_counter = 0
        print("[VIN] Batch counter reset due to new VIN.")
    resp = build_message(5, rev=1, data="0050")
    self.send_to_client(resp)
    if self.vin_subscribed:
        vin_param = self.current_vin.ljust(25)[:25]
        vin_data = build_message(52, rev=1, data=vin_param, no_ack=self.vin_no_ack)
        self.send_to_client(vin_data)
        print(f"[VIN] Sent VIN update (MID 0052): {self.current_vin}")

def _handle_mid_0051(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0051: VIN subscribe."""
    req_rev = int(rev) if rev.strip() else 1
    if req_rev > 1:
        resp = build_message(4, rev=1, data="005197")
    elif self.vin_subscribed:
        resp = build_message(4, rev=1, data="005106")
    else:
        self.vin_subscribed = True
        self.vin_no_ack = (no_ack_flag == "1")
        resp = build_message(5, rev=1, data="0051")
        print("[VIN] Subscription accepted.")
        if self.current_vin:
            vin_param = self.current_vin.ljust(25)[:25]
            vin_data = build_message(52, rev=1, data=vin_param, no_ack=self.vin_no_ack)
            self.send_to_client(vin_data)
            print(f"[VIN] Sent current VIN (MID 0052): {self.current_vin}")
    self.send_to_client(resp)

def _handle_mid_0053(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0053: VIN event acknowledged by client."""
    print("[VIN] VIN event acknowledged by client (MID 0053).")

def _handle_mid_0054(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0054: VIN unsubscribe."""
    if self.vin_subscribed:
        self.vin_subscribed = False
        resp = build_message(5, rev=1, data="0054")
        print("[VIN] Unsubscribed from VIN updates.")
    else:
        resp = build_message(4, rev=1, data="005407")
    self.send_to_client(resp)
```
  </action>
  <verify>VIN download, subscribe, ack, unsubscribe all work correctly.</verify>
  <done>VIN MID handlers (0050-0054) extracted to methods.</done>
</task>

<task type="auto">
  <name>Task 7: Extract tightening result MID handlers (0060-0063)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create handler methods for tightening result MIDs:

```python
# === Tightening Result MID Handlers ===

def _handle_mid_0060(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0060: Last tightening result data subscribe."""
    req_rev = int(rev) if rev.strip() else 1
    if req_rev > 1:
        resp = build_message(4, rev=1, data="006097")
    elif self.result_subscribed:
        resp = build_message(4, rev=1, data="006009")
    else:
        self.result_subscribed = True
        self.result_no_ack = (no_ack_flag == "1")
        resp = build_message(5, rev=1, data="0060")
        print("[Tightening] Result subscription accepted.")
    self.send_to_client(resp)

def _handle_mid_0062(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0062: Tightening result acknowledged by client."""
    print("[Tightening] Tightening result acknowledged by client (MID 0062).")

def _handle_mid_0063(self, mid_int, rev, no_ack_flag, data_field, msg):
    """MID 0063: Last tightening result unsubscribe."""
    if self.result_subscribed:
        self.result_subscribed = False
        resp = build_message(5, rev=1, data="0063")
        print("[Tightening] Unsubscribed from tightening results.")
    else:
        resp = build_message(4, rev=1, data="006310")
    self.send_to_client(resp)
```
  </action>
  <verify>Tightening subscribe/ack/unsubscribe all work correctly.</verify>
  <done>Tightening result MID handlers (0060-0063) extracted to methods.</done>
</task>

<task type="auto">
  <name>Task 8: Remove old if/elif chain and verify full functionality</name>
  <files>open_protocol_emulator.py</files>
  <action>
1. Delete the entire old if/elif chain from process_message() (the section between "# --- MID Dispatch Logic ---" and "# --- End MID Dispatch Logic ---")
2. Ensure only the new registry-based dispatch remains
3. Run emulator and verify all existing functionality works:
   - Communication start/stop
   - Keep-alive
   - Tool enable/disable
   - Pset selection and subscription
   - VIN download and subscription
   - Tightening result subscription
  </action>
  <verify>
- Emulator starts without errors
- All MID handlers respond correctly
- No regressions from previous behavior
  </verify>
  <done>Old dispatch code removed. All functionality verified working.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Code runs without syntax errors
- [ ] process_message() is under 30 lines
- [ ] All 20 MID handlers are in the registry
- [ ] Communication start/stop works
- [ ] Keep-alive echoes correctly
- [ ] Tool enable/disable sends notifications
- [ ] Pset selection and subscription works
- [ ] VIN download and subscription works
- [ ] Tightening subscription works
- [ ] Unknown MIDs return proper error
</verification>

<success_criteria>

- Registry-based dispatch pattern implemented
- process_message() reduced from ~200 lines to ~20 lines
- Each MID has a dedicated handler method
- All existing functionality preserved
- Adding new MIDs now requires: 1) add handler method, 2) register in dictionary
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-architecture-refactor/03.5-01-SUMMARY.md`
</output>
