---
phase: 05-new-mid-implementation
plan: 01
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement MID 0082 (Set Time) command handling.

Purpose: Allow integrators to set the controller's internal time via Open Protocol, completing the time management functionality expected by integration systems.
Output: Working MID 0082 handler that accepts time strings and responds with MID 0005 acknowledgment.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MID 0082 Set Time handler</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add handler for MID 0082 in the process_message() dispatch logic.

MID 0082 Format (Revision 1):
- Message sent by: Integrator
- Answer: MID 0005 Command accepted
- Data field: 19 ASCII characters at bytes 21-39 in format YYYY-MM-DD:HH:MM:SS

Implementation:
1. Add `elif mid_int == 82:` branch in process_message() after the keep-alive handler (around line 340)
2. Parse the time string from data_field (19 chars: YYYY-MM-DD:HH:MM:SS)
3. Validate format using regex or try/except with datetime.strptime
4. Store the time in a new instance variable `self.controller_time` (initialize in __init__ as None)
5. Log the received time: `[Time] Set time received: {time_string}`
6. Respond with MID 0005 acknowledgment: `build_message(5, rev=1, data="0082")`
7. If format is invalid, respond with MID 0004 error code 82 + "20" (invalid data): `build_message(4, rev=1, data="008220")`

Note: The emulator doesn't need to actually use this time for anything - it's for protocol compliance. Real tightening timestamps still use system time.

Add to __init__ around line 70:
```python
self.controller_time = None  # Set via MID 0082
```

Add handler in process_message():
```python
elif mid_int == 82:  # MID 0082 Set Time
    time_str = data_field.strip()
    if len(time_str) == 19:
        try:
            datetime.datetime.strptime(time_str, "%Y-%m-%d:%H:%M:%S")
            self.controller_time = time_str
            resp = build_message(5, rev=1, data="0082")
            print(f"[Time] Controller time set to: {time_str}")
        except ValueError:
            resp = build_message(4, rev=1, data="008220")
            print(f"[Time] Invalid time format received: {time_str}")
    else:
        resp = build_message(4, rev=1, data="008220")
        print(f"[Time] Invalid time length received: {len(time_str)} chars")
    self.send_to_client(resp)
    return
```
  </action>
  <verify>
Manual test: Send MID 0082 with valid time string, verify MID 0005 response.
Manual test: Send MID 0082 with invalid time, verify MID 0004 response.
Code review: Verify handler follows existing patterns in process_message().
  </verify>
  <done>
- MID 0082 handler exists in process_message()
- Valid time format accepted with MID 0005 response
- Invalid time format rejected with MID 0004 error
- Controller time stored in instance variable
- Log output shows time setting events
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Code runs without syntax errors
- [ ] MID 0082 handler follows existing dispatch pattern
- [ ] Time format validation works (accepts valid, rejects invalid)
- [ ] Response messages use correct MID numbers and format
</verification>

<success_criteria>

- MID 0082 implemented per Open Protocol spec
- Integrator can set controller time
- Invalid requests properly rejected
- No regressions to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/05-new-mid-implementation/05-01-SUMMARY.md`
</output>
