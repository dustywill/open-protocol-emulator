---
phase: 05-new-mid-implementation
plan: 03
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement MID 0214-0219 (I/O device status and Relay functions) message handling using the registry-based dispatch pattern.

Purpose: Enable emulation of I/O device status queries and relay function subscriptions. This allows testing of integrations that monitor controller I/O state and relay outputs for production control systems.
Output: Working I/O device status request/reply and relay function subscription/notification/acknowledge/unsubscribe flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add I/O device and relay state variables</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add instance variables in __init__ (around line 130, after multi-spindle state):

```python
# --- I/O Device and Relay State ---
self.io_devices = {
    "00": {  # Internal device
        "relays": [
            {"function": 1, "status": 0},   # OK relay
            {"function": 2, "status": 0},   # NOK relay
            {"function": 9, "status": 0},   # Cycle complete
            {"function": 10, "status": 0},  # Alarm
            {"function": 18, "status": 1},  # POWER FOCUS ready
            {"function": 19, "status": 1},  # Tool ready
            {"function": 30, "status": 0},  # Tool locked
            {"function": 0, "status": 0},   # Off (unused)
        ],
        "digital_inputs": [
            {"function": 0, "status": 0},
            {"function": 0, "status": 0},
            {"function": 0, "status": 0},
            {"function": 0, "status": 0},
            {"function": 0, "status": 0},
            {"function": 0, "status": 0},
            {"function": 0, "status": 0},
            {"function": 0, "status": 0},
        ]
    }
}
self.relay_subscriptions = {}  # {relay_function_number: no_ack_flag}
```

Also add max revision constant near other MAX_REV constants:
```python
MAX_REV_0215 = 2  # I/O device status supports rev 1-2
```

This provides:
- A simulated internal I/O device (device 00) with 8 relays and 8 digital inputs
- Common relay functions pre-configured (OK, NOK, cycle complete, alarm, ready states)
- Relay subscription tracking dictionary for MID 0216/0217 flow
  </action>
  <verify>Code runs without syntax errors after adding variables.</verify>
  <done>I/O device and relay state variables exist in __init__.</done>
</task>

<task type="auto">
  <name>Task 2: Implement _handle_mid_0214 I/O device status request (Rev 1-2)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create handler for MID 0214 I/O device status request and build MID 0215 response.

MID 0214 Format (Rev 1 and 2 - same format):
- Device number: 2 digits (00-15), where 00=internal device

MID 0215 Revision Differences:
- **Rev 1**: Fixed 8 relays + 8 digital inputs (for devices with max 8 I/O)
  - Field 01: IO device ID (2 digits)
  - Field 02: Relay list - 8 relays × 4 bytes each (function 3 digits + status 1 digit)
  - Field 03: Digital input list - 8 inputs × 4 bytes each

- **Rev 2**: Variable relay/input count (for devices with more I/O)
  - Field 01: IO device ID (2 digits)
  - Field 02: Number of relays (2 digits)
  - Field 03: Relay list - N relays × 4 bytes each
  - Field 04: Number of digital inputs (2 digits)
  - Field 05: Digital input list - M inputs × 4 bytes each

Add handler method:

```python
def _handle_mid_0214(self, mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes):
    """MID 0214: I/O device status request (Rev 1-2)."""
    device_num = data_field[:2] if len(data_field) >= 2 else "00"
    req_rev = int(rev.strip()) if rev.strip() else 1

    if req_rev > self.MAX_REV_0215:
        error_data = self._build_mid0004_data(1, 214, 97)
        resp = build_message(4, rev=1, data=error_data)
        print(f"[IO] Revision {req_rev} not supported for MID 0214.")
    elif device_num not in self.io_devices:
        error_data = self._build_mid0004_data(1, 214, 1)
        resp = build_message(4, rev=1, data=error_data)
        print(f"[IO] Device {device_num} not found.")
    else:
        device = self.io_devices[device_num]
        relays = device["relays"]
        digital_inputs = device["digital_inputs"]

        if req_rev == 1:
            # Revision 1: Fixed 8 relays + 8 digital inputs
            fields = []
            fields.append(f"01{device_num}")

            # Relay list (8 relays, 4 bytes each: 3-digit function + 1-digit status)
            relay_data = ""
            for relay in relays[:8]:
                relay_data += f"{relay['function']:03d}{relay['status']}"
            # Pad to 8 relays if fewer
            while len(relay_data) < 32:
                relay_data += "0000"
            fields.append(f"02{relay_data}")

            # Digital input list (8 inputs, 4 bytes each)
            din_data = ""
            for din in digital_inputs[:8]:
                din_data += f"{din['function']:03d}{din['status']}"
            # Pad to 8 inputs if fewer
            while len(din_data) < 32:
                din_data += "0000"
            fields.append(f"03{din_data}")

            data = "".join(fields)
            resp = build_message(215, rev=1, data=data)

        else:  # req_rev == 2
            # Revision 2: Variable count with field numbers
            fields = []
            fields.append(f"01{device_num}")
            fields.append(f"02{len(relays):02d}")  # Number of relays

            # Relay list
            relay_data = ""
            for relay in relays:
                relay_data += f"{relay['function']:03d}{relay['status']}"
            fields.append(f"03{relay_data}")

            fields.append(f"04{len(digital_inputs):02d}")  # Number of digital inputs

            # Digital input list
            din_data = ""
            for din in digital_inputs:
                din_data += f"{din['function']:03d}{din['status']}"
            fields.append(f"05{din_data}")

            data = "".join(fields)
            resp = build_message(215, rev=2, data=data)

        print(f"[IO] Sent device {device_num} status (MID 0215 rev {req_rev}).")

    self.send_to_client(resp)
```
  </action>
  <verify>
- Send MID 0214 rev 1 with device "00", verify MID 0215 rev 1 response (fixed 8+8 format)
- Send MID 0214 rev 2 with device "00", verify MID 0215 rev 2 response (variable count format)
- Send MID 0214 rev 3+, verify MID 0004 error 97 (revision unsupported)
- Send MID 0214 with invalid device "99", verify MID 0004 error
  </verify>
  <done>
- MID 0214 request handler parses device number and requested revision
- MID 0215 revision 1 built with fixed 8+8 relay/input format
- MID 0215 revision 2 built with variable count format
- Revision 3+ rejected with proper error
- Invalid device ID returns proper error
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement _handle_mid_0216 subscribe and _handle_mid_0219 unsubscribe</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add handlers for relay function subscription:

MID 0216 Format (Rev 1):
- Relay function number: 3 digits (see relay function table)
- Supports multiple simultaneous relay subscriptions (different functions)

MID 0219 Format (Rev 1):
- Relay function number: 3 digits
- Unsubscribes from specific relay function

```python
def _handle_mid_0216(self, mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes):
    """MID 0216: Relay function subscribe."""
    relay_func = data_field[:3] if len(data_field) >= 3 else "000"

    try:
        relay_num = int(relay_func)
    except ValueError:
        error_data = self._build_mid0004_data(1, 216, 99)
        resp = build_message(4, rev=1, data=error_data)
        self.send_to_client(resp)
        return

    if relay_num in self.relay_subscriptions:
        error_data = self._build_mid0004_data(1, 216, 6)
        resp = build_message(4, rev=1, data=error_data)
        print(f"[Relay] Subscription for relay function {relay_num} already exists.")
    else:
        self.relay_subscriptions[relay_num] = (no_ack_flag == "1")
        resp = build_message(5, rev=1, data="0216")
        print(f"[Relay] Subscribed to relay function {relay_num}.")

        # Send accept first, then immediately send current status per spec
        self.send_to_client(resp)
        self._send_relay_status(relay_num)
        return

    self.send_to_client(resp)

def _handle_mid_0219(self, mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes):
    """MID 0219: Relay function unsubscribe."""
    relay_func = data_field[:3] if len(data_field) >= 3 else "000"

    try:
        relay_num = int(relay_func)
    except ValueError:
        error_data = self._build_mid0004_data(1, 219, 99)
        resp = build_message(4, rev=1, data=error_data)
        self.send_to_client(resp)
        return

    if relay_num in self.relay_subscriptions:
        del self.relay_subscriptions[relay_num]
        resp = build_message(5, rev=1, data="0219")
        print(f"[Relay] Unsubscribed from relay function {relay_num}.")
    else:
        error_data = self._build_mid0004_data(1, 219, 7)
        resp = build_message(4, rev=1, data=error_data)
        print(f"[Relay] Unsubscribe failed: not subscribed to relay {relay_num}.")

    self.send_to_client(resp)
```

Add helper method to send relay status (add after send_multi_spindle_result):

```python
def _send_relay_status(self, relay_func: int):
    """Send MID 0217 relay function status for a subscribed relay."""
    # Find relay status in internal device
    status = 0
    for device in self.io_devices.values():
        for relay in device["relays"]:
            if relay["function"] == relay_func:
                status = relay["status"]
                break

    no_ack = self.relay_subscriptions.get(relay_func, False)

    # MID 0217 format: 01 + relay_func(3) + 02 + status(1)
    data = f"01{relay_func:03d}02{status}"
    msg = build_message(217, rev=1, data=data, no_ack=no_ack)
    self.send_to_client(msg)
    print(f"[Relay] Sent relay {relay_func} status: {status} (MID 0217)")
```

Also update handle_client() cleanup to clear relay subscriptions:
```python
self.relay_subscriptions = {}
```
  </action>
  <verify>
- Send MID 0216 with relay function 001, verify MID 0005 and immediate MID 0217 with status
- Send MID 0216 again for same relay, verify MID 0004 already subscribed
- Send MID 0219 to unsubscribe, verify MID 0005
- Send MID 0219 when not subscribed, verify MID 0004 error
  </verify>
  <done>
- MID 0216 subscribe handler works with immediate status notification
- MID 0219 unsubscribe handler works
- Multiple relay subscriptions supported
- Subscription state cleared on client disconnect
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement _handle_mid_0218 acknowledge handler</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add handler for MID 0218 (acknowledgment from integrator after receiving MID 0217):

```python
def _handle_mid_0218(self, mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes):
    """MID 0218: Relay function acknowledge."""
    print("[Relay] Relay function acknowledged by client (MID 0218).")
    # No response needed per spec
```

This completes the relay function subscription flow:
- Integrator sends MID 0216 (subscribe)
- Controller sends MID 0005 (accepted) + MID 0217 (current status)
- Integrator sends MID 0218 (acknowledge)
- Controller sends MID 0217 whenever relay status changes (tracking events)
- Integrator sends MID 0218 (acknowledge each change)
  </action>
  <verify>Send MID 0218 after receiving MID 0217, verify it's accepted without response.</verify>
  <done>MID 0218 acknowledge handler logs receipt and returns without response.</done>
</task>

<task type="auto">
  <name>Task 5: Register MID 0214-0219 handlers in dispatch registry</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add the MID 0214-0219 handlers to the mid_handlers dictionary in _register_mid_handlers() method:

```python
214: self._handle_mid_0214,
216: self._handle_mid_0216,
218: self._handle_mid_0218,
219: self._handle_mid_0219,
```

Note: MID 0215 and MID 0217 are sent by the controller to the integrator (not received), so they don't need handlers.
  </action>
  <verify>
Verify registration by checking that mid_handlers dict includes keys 214, 216, 218, 219.
  </verify>
  <done>
- MID 0214 I/O status request handler registered
- MID 0216 relay subscribe handler registered
- MID 0218 relay acknowledge handler registered
- MID 0219 relay unsubscribe handler registered
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Code runs without syntax errors
- [ ] MID 0214 rev 1 → MID 0215 rev 1 (fixed 8+8 format)
- [ ] MID 0214 rev 2 → MID 0215 rev 2 (variable count format)
- [ ] MID 0214 rev 3+ returns MID 0004 error 97 (revision unsupported)
- [ ] MID 0214 returns MID 0004 for invalid device
- [ ] MID 0216 subscription works and sends immediate MID 0217
- [ ] MID 0218 acknowledge is accepted
- [ ] MID 0219 unsubscribe works with proper error handling
- [ ] All subscription states cleared on client disconnect
</verification>

<success_criteria>

- I/O device status query (0214 → 0215) works for both revision 1 and 2
- Relay function subscription flow (0216 → 0217 → 0218) works
- Relay unsubscribe (0219) properly implemented
- Simulated I/O device has realistic relay configuration
- Subscription state managed correctly across connection lifecycle
- Handlers follow established registry pattern
</success_criteria>

<output>
After completion, create `.planning/phases/05-new-mid-implementation/05-03-SUMMARY.md`
</output>
