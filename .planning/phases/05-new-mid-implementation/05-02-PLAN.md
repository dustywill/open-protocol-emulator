---
phase: 05-new-mid-implementation
plan: 02
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement MID 0100-0102 (Multi-spindle result) message handling.

Purpose: Support multi-spindle controller emulation where multiple spindles operate in sync. This is essential for testing integrations with PowerMACS or Power Focus sync masters that coordinate multiple tightening tools.
Output: Working subscription/result/acknowledge flow for multi-spindle tightening results.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-revision/04-RESEARCH.md

@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi-spindle state variables and configuration</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add instance variables in __init__ (around line 70, after existing subscription flags):

```python
# --- Multi-spindle State ---
self.multi_spindle_subscribed = False
self.multi_spindle_no_ack = False
self.multi_spindle_requested_rev = 1
self.sync_tightening_id = 0
self.num_spindles = 2  # Simulated number of spindles (2-10 per spec)
# --- End Multi-spindle State ---
```

These variables track:
- Subscription state for multi-spindle results
- The revision level requested (rev 1-5 supported, but we implement rev 1 format)
- A counter for sync tightening IDs (unique per sync operation)
- Configurable number of simulated spindles
  </action>
  <verify>Code runs without syntax errors after adding variables.</verify>
  <done>Multi-spindle state variables exist in __init__.</done>
</task>

<task type="auto">
  <name>Task 2: Implement MID 0100 Multi-spindle result subscribe handler (Rev 1-5)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add handler for MID 0100 in process_message() after MID 0063 handler (around line 463).

MID 0100 Revision Support:
- Revision 1: No data field (basic subscription)
- Revision 2: Data No System (10 digits) - rewind point for historical data
- Revision 3-5: Data No System + Send only new data flag (1 digit)

We support all revisions 1-5. Revision 2+ data fields are accepted but the emulator will only send new results (no historical rewind functionality).

```python
elif mid_int == 100:  # MID 0100 Multi-spindle result subscribe
    no_ack_flag = msg[11:12].decode('ascii')
    req_rev = int(rev) if rev.strip() else 1

    if req_rev > 5:
        resp = build_message(4, rev=1, data="010097")  # Revision unsupported
    elif self.multi_spindle_subscribed:
        resp = build_message(4, rev=1, data="010009")  # Already subscribed
    else:
        self.multi_spindle_subscribed = True
        self.multi_spindle_no_ack = (no_ack_flag == "1")
        self.multi_spindle_requested_rev = req_rev  # Store requested revision for MID 0101 format

        # Parse optional data fields (rev 2+: rewind point, rev 3+: send only new)
        # These are accepted but emulator always sends new results only
        if req_rev >= 2 and len(data_field) >= 10:
            rewind_point = data_field[:10]
            print(f"[MultiSpindle] Rewind point requested: {rewind_point} (ignored, emulator sends new only)")
        if req_rev >= 3 and len(data_field) >= 11:
            send_only_new = data_field[10:11]
            print(f"[MultiSpindle] Send only new flag: {send_only_new}")

        resp = build_message(5, rev=1, data="0100")
        print(f"[MultiSpindle] Subscription accepted (revision {req_rev}).")
    self.send_to_client(resp)
    return
```
  </action>
  <verify>Send MID 0100 rev 1-5, verify MID 0005 response. Send rev 6+, verify MID 0004 error 97.</verify>
  <done>MID 0100 subscribe handler accepts revisions 1-5 with proper error handling.</done>
</task>

<task type="auto">
  <name>Task 3: Implement MID 0101 Multi-spindle result builder (Rev 1-5)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create method to build and send MID 0101 multi-spindle result with revision support.

MID 0101 Revision Format Differences:
- **Rev 1-3**: Same format - header fields + repeating spindle data (18 bytes each)
- **Rev 4**: Adds Field 19 "System sub type" (3 digits) after spindle data
- **Rev 5**: Adds Field 20 "Job sequence number" (5 digits) after system sub type

Common Format (All Revisions):
- Field 01: Number of spindles (2 digits)
- Field 02: VIN number (25 chars)
- Field 03: Job ID (2 digits)
- Field 04: Parameter set ID (3 digits)
- Field 05: Batch size (4 digits)
- Field 06: Batch counter (4 digits)
- Field 07: Batch status (1 digit: 0=NOK, 1=OK, 2=unused)
- Field 08: Torque min limit (6 digits, x100)
- Field 09: Torque max limit (6 digits, x100)
- Field 10: Torque final target (6 digits, x100)
- Field 11: Angle min (5 digits)
- Field 12: Angle max (5 digits)
- Field 13: Final angle target (5 digits)
- Field 14: Pset last change time (19 chars)
- Field 15: Time stamp (19 chars)
- Field 16: Sync tightening ID (5 digits, 00000-65535)
- Field 17: Sync overall status (1 digit: 0=NOK, 1=OK)
- Field 18: Spindle data (repeating, 18 bytes per spindle)
  - Spindle number (2 digits)
  - Channel ID (2 digits)
  - Overall status (1 digit: 0=NOK, 1=OK)
  - Torque status (1 digit: 0=Low, 1=OK, 2=High)
  - Torque result (6 digits, x100)
  - Angle status (1 digit: 0=Low, 1=OK, 2=High)
  - Angle result (5 digits)
- Field 19 (Rev 4+): System sub type (3 digits) - "001" for tightening spindles
- Field 20 (Rev 5): Job sequence number (5 digits)

Add method after send_single_tightening_result() (around line 575):

```python
def send_multi_spindle_result(self):
    """Generate and send a simulated MID 0101 multi-spindle result (supports Rev 1-5)."""
    if not self.tool_enabled:
        print("[MultiSpindle] Send prevented: Tool is disabled.")
        return
    if not self.session_active or not self.multi_spindle_subscribed:
        print("[MultiSpindle] Send prevented: Session inactive or not subscribed.")
        return

    self.sync_tightening_id = (self.sync_tightening_id + 1) % 65536
    timestamp_str = datetime.datetime.now().strftime("%Y-%m-%d:%H:%M:%S")
    revision = self.multi_spindle_requested_rev

    # Get parameters from current Pset or defaults
    current_pset_params = self.pset_parameters.get(self.current_pset)
    if current_pset_params:
        target_torque = current_pset_params["target_torque"]
        torque_min = current_pset_params["torque_min"]
        torque_max = current_pset_params["torque_max"]
        target_angle = current_pset_params["target_angle"]
        angle_min = current_pset_params["angle_min"]
        angle_max = current_pset_params["angle_max"]
        batch_size = current_pset_params["batch_size"]
    else:
        target_torque, torque_min, torque_max = 50.00, 47.00, 53.00
        target_angle, angle_min, angle_max = 90, 80, 100
        batch_size = self.target_batch_size

    pset_change_ts = (self.pset_last_change.strftime("%Y-%m-%d:%H:%M:%S")
                      if self.pset_last_change else timestamp_str)

    # Build header fields
    fields = []
    fields.append(f"01{self.num_spindles:02d}")  # Number of spindles
    fields.append(f"02{self.current_vin.ljust(25)[:25]}")  # VIN
    fields.append(f"03{0:02d}")  # Job ID
    fields.append(f"04{(self.current_pset if self.current_pset else '0').rjust(3, '0')}")  # Pset ID
    fields.append(f"05{batch_size:04d}")  # Batch size
    fields.append(f"06{self.batch_counter:04d}")  # Batch counter
    fields.append(f"07{'0'}")  # Batch status (0=not complete for multi-spindle demo)
    fields.append(f"08{int(torque_min * 100):06d}")  # Torque min
    fields.append(f"09{int(torque_max * 100):06d}")  # Torque max
    fields.append(f"10{int(target_torque * 100):06d}")  # Torque target
    fields.append(f"11{int(angle_min):05d}")  # Angle min
    fields.append(f"12{int(angle_max):05d}")  # Angle max
    fields.append(f"13{int(target_angle):05d}")  # Angle target
    fields.append(f"14{pset_change_ts}")  # Pset last change
    fields.append(f"15{timestamp_str}")  # Timestamp
    fields.append(f"16{self.sync_tightening_id:05d}")  # Sync tightening ID

    # Generate spindle results
    spindle_results = []
    all_ok = True
    for spindle_num in range(1, self.num_spindles + 1):
        is_nok = random.random() < self.nok_probability
        status = "0" if is_nok else "1"
        if is_nok:
            all_ok = False

        torque_status = "1"
        angle_status = "1"
        actual_torque = random.uniform(torque_min, torque_max)
        actual_angle = random.uniform(angle_min, angle_max)

        if is_nok:
            if random.choice(["torque", "angle"]) == "torque":
                torque_status = random.choice(["0", "2"])
                actual_torque = random.uniform(torque_min - 5, torque_min - 0.1) if torque_status == "0" else random.uniform(torque_max + 0.1, torque_max + 5)
            else:
                angle_status = random.choice(["0", "2"])
                actual_angle = random.uniform(angle_min - 20, angle_min - 1) if angle_status == "0" else random.uniform(angle_max + 1, angle_max + 20)

        spindle_results.append({
            "num": spindle_num,
            "channel": spindle_num,
            "status": status,
            "torque_status": torque_status,
            "angle_status": angle_status,
            "torque": int(actual_torque * 100),
            "angle": int(actual_angle)
        })

    # Overall status
    overall_status = "1" if all_ok else "0"
    fields.append(f"17{overall_status}")

    # Spindle data (Field 18)
    spindle_data = ""
    for s in spindle_results:
        spindle_data += f"{s['num']:02d}{s['channel']:02d}{s['status']}{s['torque_status']}{s['torque']:06d}{s['angle_status']}{s['angle']:05d}"
    fields.append(f"18{spindle_data}")

    # Rev 4+: System sub type (Field 19) - "001" = normal tightening spindles
    if revision >= 4:
        fields.append(f"19{'001'}")

    # Rev 5: Job sequence number (Field 20)
    if revision >= 5:
        fields.append(f"20{0:05d}")  # Job sequence, 00000 when unused

    data = "".join(fields)
    result_msg = build_message(101, rev=revision, data=data, no_ack=self.multi_spindle_no_ack)
    self.send_to_client(result_msg)
    print(f"[MultiSpindle] Sent result (MID 0101 rev {revision}, SyncID: {self.sync_tightening_id:05d}). Status: {'OK' if all_ok else 'NOK'}, Spindles: {self.num_spindles}")
```

Note: Multi-spindle results are sent on-demand, not automatically. The revision used matches what was requested in MID 0100 subscription.
  </action>
  <verify>
- Subscribe with MID 0100 rev 1, call send_multi_spindle_result(), verify MID 0101 rev 1 format
- Subscribe with MID 0100 rev 4, verify MID 0101 includes system sub type field
- Subscribe with MID 0100 rev 5, verify MID 0101 includes job sequence number
  </verify>
  <done>MID 0101 builder creates correctly formatted multi-spindle result messages for revisions 1-5.</done>
</task>

<task type="auto">
  <name>Task 4: Implement MID 0102 Multi-spindle result acknowledge and MID 0103 unsubscribe handlers</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add handlers for MID 0102 (acknowledge) and MID 0103 (unsubscribe) in process_message():

```python
elif mid_int == 102:  # MID 0102 Multi-spindle result acknowledge
    print("[MultiSpindle] Result acknowledged by client (MID 0102).")
    # No response needed per spec
    return

elif mid_int == 103:  # MID 0103 Multi-spindle result unsubscribe
    if self.multi_spindle_subscribed:
        self.multi_spindle_subscribed = False
        resp = build_message(5, rev=1, data="0103")
        print("[MultiSpindle] Unsubscribed from multi-spindle results.")
    else:
        resp = build_message(4, rev=1, data="010310")  # Not subscribed
        print("[MultiSpindle] Unsubscribe failed: not subscribed.")
    self.send_to_client(resp)
    return
```

Also update the cleanup in handle_client() (around line 289) to reset multi-spindle subscription:

```python
self.multi_spindle_subscribed = False
```
  </action>
  <verify>
- Send MID 0102 after receiving MID 0101, verify it's accepted without response
- Send MID 0103 when subscribed, verify MID 0005
- Send MID 0103 when not subscribed, verify MID 0004 error
  </verify>
  <done>
- MID 0102 acknowledge handler logs receipt
- MID 0103 unsubscribe handler works with proper error handling
- Subscription state cleared on client disconnect
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Code runs without syntax errors
- [ ] MID 0100 subscription works for revisions 1-5, rejects rev 6+
- [ ] MID 0100 prevents double subscription
- [ ] MID 0101 message format matches spec for requested revision
- [ ] MID 0101 rev 4+ includes system sub type field
- [ ] MID 0101 rev 5 includes job sequence number field
- [ ] MID 0102 acknowledge is accepted
- [ ] MID 0103 unsubscribe works and handles not-subscribed error
- [ ] Multi-spindle state resets on client disconnect
</verification>

<success_criteria>

- Multi-spindle subscription flow (0100 → 0101 → 0102) works with revision support
- All 5 revisions of MID 0100/0101 properly supported
- Unsubscribe (0103) properly implemented
- Simulated multi-spindle results have realistic data
- Subscription state managed correctly across connection lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/05-new-mid-implementation/05-02-SUMMARY.md`
</output>
