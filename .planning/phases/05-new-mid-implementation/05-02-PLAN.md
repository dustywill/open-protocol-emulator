---
phase: 05-new-mid-implementation
plan: 02
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement MID 0100-0103 (Multi-spindle result) message handling using the registry-based dispatch pattern.

Purpose: Support multi-spindle controller emulation where multiple spindles operate in sync. This is essential for testing integrations with PowerMACS or Power Focus sync masters that coordinate multiple tightening tools.
Output: Working subscription/result/acknowledge/unsubscribe flow for multi-spindle tightening results with revision support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-revision/04-RESEARCH.md

@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi-spindle state variables</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add instance variables in __init__ (around line 130, after existing subscription flags):

```python
# --- Multi-spindle State ---
self.multi_spindle_subscribed = False
self.multi_spindle_no_ack = False
self.multi_spindle_requested_rev = 1
self.sync_tightening_id = 0
self.num_spindles = 2  # Simulated number of spindles (2-10 per spec)
```

These variables track:
- Subscription state for multi-spindle results
- The revision level requested (rev 1-5 supported)
- A counter for sync tightening IDs (unique per sync operation, 00000-65535)
- Configurable number of simulated spindles

Also add max revision constant near other MAX_REV constants (around line 60):
```python
MAX_REV_0101 = 5  # Multi-spindle result supports rev 1-5
```
  </action>
  <verify>Code runs without syntax errors after adding variables.</verify>
  <done>Multi-spindle state variables exist in __init__.</done>
</task>

<task type="auto">
  <name>Task 2: Implement _handle_mid_0100 subscribe handler (Rev 1-5)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create handler for MID 0100 Multi-spindle result subscribe.

MID 0100 Revision Support:
- Revision 1: No data field (basic subscription)
- Revision 2: Data No System (10 digits) - rewind point for historical data
- Revision 3-5: Data No System + Send only new data flag (1 digit)

Add handler method after _handle_mid_0082:

```python
def _handle_mid_0100(self, mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes):
    """MID 0100: Multi-spindle result subscribe (Rev 1-5)."""
    req_rev = int(rev.strip()) if rev.strip() else 1

    if req_rev > self.MAX_REV_0101:
        error_data = self._build_mid0004_data(1, 100, 97)
        resp = build_message(4, rev=1, data=error_data)
        print(f"[MultiSpindle] Revision {req_rev} not supported (max: {self.MAX_REV_0101}).")
    elif self.multi_spindle_subscribed:
        error_data = self._build_mid0004_data(1, 100, 9)
        resp = build_message(4, rev=1, data=error_data)
        print("[MultiSpindle] Subscribe failed: already subscribed.")
    else:
        self.multi_spindle_subscribed = True
        self.multi_spindle_no_ack = (no_ack_flag == "1")
        self.multi_spindle_requested_rev = req_rev

        # Parse optional data fields (rev 2+: rewind point, rev 3+: send only new)
        # These are accepted but emulator always sends new results only
        if req_rev >= 2 and len(data_field) >= 10:
            rewind_point = data_field[:10]
            print(f"[MultiSpindle] Rewind point requested: {rewind_point} (ignored, emulator sends new only)")
        if req_rev >= 3 and len(data_field) >= 11:
            send_only_new = data_field[10:11]
            print(f"[MultiSpindle] Send only new flag: {send_only_new}")

        resp = build_message(5, rev=1, data="0100")
        print(f"[MultiSpindle] Subscription accepted (revision {req_rev}).")

    self.send_to_client(resp)
```
  </action>
  <verify>Send MID 0100 rev 1-5, verify MID 0005 response. Send rev 6+, verify MID 0004 error 97.</verify>
  <done>MID 0100 subscribe handler accepts revisions 1-5 with proper error handling.</done>
</task>

<task type="auto">
  <name>Task 3: Implement send_multi_spindle_result method (MID 0101 Rev 1-5)</name>
  <files>open_protocol_emulator.py</files>
  <action>
Create method to build and send MID 0101 multi-spindle result with revision support.

MID 0101 Revision Format Differences:
- **Rev 1-3**: Same format - header fields + repeating spindle data (18 bytes each)
- **Rev 4**: Adds Field 19 "System sub type" (3 digits) after spindle data
- **Rev 5**: Adds Field 20 "Job sequence number" (5 digits) after system sub type

Add method after send_single_tightening_result (around line 900):

```python
def send_multi_spindle_result(self):
    """Generate and send a simulated MID 0101 multi-spindle result (supports Rev 1-5)."""
    if not self.tool_enabled:
        print("[MultiSpindle] Send prevented: Tool is disabled.")
        return
    if not self.session_active or not self.multi_spindle_subscribed:
        print("[MultiSpindle] Send prevented: Session inactive or not subscribed.")
        return

    self.sync_tightening_id = (self.sync_tightening_id + 1) % 65536
    timestamp_str = datetime.datetime.now().strftime("%Y-%m-%d:%H:%M:%S")
    revision = self.multi_spindle_requested_rev

    # Get parameters from current Pset or defaults
    current_pset_params = self.pset_parameters.get(self.current_pset)
    if current_pset_params:
        target_torque = current_pset_params["target_torque"]
        torque_min = current_pset_params["torque_min"]
        torque_max = current_pset_params["torque_max"]
        target_angle = current_pset_params["target_angle"]
        angle_min = current_pset_params["angle_min"]
        angle_max = current_pset_params["angle_max"]
        batch_size = current_pset_params["batch_size"]
    else:
        target_torque, torque_min, torque_max = 50.00, 47.00, 53.00
        target_angle, angle_min, angle_max = 90, 80, 100
        batch_size = self.target_batch_size

    pset_change_ts = (self.pset_last_change.strftime("%Y-%m-%d:%H:%M:%S")
                      if self.pset_last_change else timestamp_str)

    # Build header fields (Field 01-16)
    fields = []
    fields.append(f"01{self.num_spindles:02d}")  # Number of spindles
    fields.append(f"02{self.current_vin.ljust(25)[:25]}")  # VIN
    fields.append(f"03{0:02d}")  # Job ID
    fields.append(f"04{(self.current_pset if self.current_pset else '0').rjust(3, '0')}")  # Pset ID
    fields.append(f"05{batch_size:04d}")  # Batch size
    fields.append(f"06{self.batch_counter:04d}")  # Batch counter
    fields.append(f"07{'0'}")  # Batch status (0=not complete for multi-spindle demo)
    fields.append(f"08{int(torque_min * 100):06d}")  # Torque min
    fields.append(f"09{int(torque_max * 100):06d}")  # Torque max
    fields.append(f"10{int(target_torque * 100):06d}")  # Torque target
    fields.append(f"11{int(angle_min):05d}")  # Angle min
    fields.append(f"12{int(angle_max):05d}")  # Angle max
    fields.append(f"13{int(target_angle):05d}")  # Angle target
    fields.append(f"14{pset_change_ts}")  # Pset last change
    fields.append(f"15{timestamp_str}")  # Timestamp
    fields.append(f"16{self.sync_tightening_id:05d}")  # Sync tightening ID

    # Generate spindle results
    spindle_results = []
    all_ok = True
    for spindle_num in range(1, self.num_spindles + 1):
        is_nok = random.random() < self.nok_probability
        status = "0" if is_nok else "1"
        if is_nok:
            all_ok = False

        torque_status = "1"
        angle_status = "1"
        actual_torque = random.uniform(torque_min, torque_max)
        actual_angle = random.uniform(angle_min, angle_max)

        if is_nok:
            if random.choice(["torque", "angle"]) == "torque":
                torque_status = random.choice(["0", "2"])
                actual_torque = random.uniform(torque_min - 5, torque_min - 0.1) if torque_status == "0" else random.uniform(torque_max + 0.1, torque_max + 5)
            else:
                angle_status = random.choice(["0", "2"])
                actual_angle = random.uniform(angle_min - 20, angle_min - 1) if angle_status == "0" else random.uniform(angle_max + 1, angle_max + 20)

        spindle_results.append({
            "num": spindle_num,
            "channel": spindle_num,
            "status": status,
            "torque_status": torque_status,
            "angle_status": angle_status,
            "torque": int(actual_torque * 100),
            "angle": int(actual_angle)
        })

    # Overall status (Field 17)
    overall_status = "1" if all_ok else "0"
    fields.append(f"17{overall_status}")

    # Spindle data (Field 18) - 18 bytes per spindle
    spindle_data = ""
    for s in spindle_results:
        spindle_data += f"{s['num']:02d}{s['channel']:02d}{s['status']}{s['torque_status']}{s['torque']:06d}{s['angle_status']}{s['angle']:05d}"
    fields.append(f"18{spindle_data}")

    # Rev 4+: System sub type (Field 19) - "001" = normal tightening spindles
    if revision >= 4:
        fields.append(f"19{'001'}")

    # Rev 5: Job sequence number (Field 20)
    if revision >= 5:
        fields.append(f"20{0:05d}")  # Job sequence, 00000 when unused

    data = "".join(fields)
    result_msg = build_message(101, rev=revision, data=data, no_ack=self.multi_spindle_no_ack)
    self.send_to_client(result_msg)
    print(f"[MultiSpindle] Sent result (MID 0101 rev {revision}, SyncID: {self.sync_tightening_id:05d}). Status: {'OK' if all_ok else 'NOK'}, Spindles: {self.num_spindles}")
```
  </action>
  <verify>
- Subscribe with MID 0100 rev 1, call send_multi_spindle_result(), verify MID 0101 rev 1 format
- Subscribe with MID 0100 rev 4, verify MID 0101 includes system sub type field
- Subscribe with MID 0100 rev 5, verify MID 0101 includes job sequence number
  </verify>
  <done>MID 0101 builder creates correctly formatted multi-spindle result messages for revisions 1-5.</done>
</task>

<task type="auto">
  <name>Task 4: Implement _handle_mid_0102 acknowledge and _handle_mid_0103 unsubscribe handlers</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add handlers for MID 0102 (acknowledge) and MID 0103 (unsubscribe):

```python
def _handle_mid_0102(self, mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes):
    """MID 0102: Multi-spindle result acknowledge."""
    print("[MultiSpindle] Result acknowledged by client (MID 0102).")
    # No response needed per spec

def _handle_mid_0103(self, mid_int: int, rev: str, no_ack_flag: str, data_field: str, msg: bytes):
    """MID 0103: Multi-spindle result unsubscribe."""
    if self.multi_spindle_subscribed:
        self.multi_spindle_subscribed = False
        self.multi_spindle_no_ack = False
        resp = build_message(5, rev=1, data="0103")
        print("[MultiSpindle] Unsubscribed from multi-spindle results.")
    else:
        error_data = self._build_mid0004_data(1, 103, 10)
        resp = build_message(4, rev=1, data=error_data)
        print("[MultiSpindle] Unsubscribe failed: not subscribed.")
    self.send_to_client(resp)
```

Also update the cleanup in handle_client() (around line 750) to reset multi-spindle subscription:

```python
self.multi_spindle_subscribed = False
self.multi_spindle_no_ack = False
```
  </action>
  <verify>
- Send MID 0102 after receiving MID 0101, verify it's accepted without response
- Send MID 0103 when subscribed, verify MID 0005
- Send MID 0103 when not subscribed, verify MID 0004 error
  </verify>
  <done>
- MID 0102 acknowledge handler logs receipt
- MID 0103 unsubscribe handler works with proper error handling
- Subscription state cleared on client disconnect
  </done>
</task>

<task type="auto">
  <name>Task 5: Register MID 0100-0103 handlers in dispatch registry</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add the MID 0100-0103 handlers to the mid_handlers dictionary in _register_mid_handlers() method:

```python
100: self._handle_mid_0100,
102: self._handle_mid_0102,
103: self._handle_mid_0103,
```

Note: MID 0101 is sent by the controller to the integrator (not received), so it doesn't need a handler.
  </action>
  <verify>
Verify registration by checking that mid_handlers dict includes keys 100, 102, 103.
  </verify>
  <done>
- MID 0100 subscribe handler registered
- MID 0102 acknowledge handler registered
- MID 0103 unsubscribe handler registered
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Code runs without syntax errors
- [ ] MID 0100 subscription works for revisions 1-5, rejects rev 6+
- [ ] MID 0100 prevents double subscription
- [ ] MID 0101 message format matches spec for requested revision
- [ ] MID 0101 rev 4+ includes system sub type field
- [ ] MID 0101 rev 5 includes job sequence number field
- [ ] MID 0102 acknowledge is accepted
- [ ] MID 0103 unsubscribe works and handles not-subscribed error
- [ ] Multi-spindle state resets on client disconnect
</verification>

<success_criteria>

- Multi-spindle subscription flow (0100 → 0101 → 0102) works with revision support
- All 5 revisions of MID 0100/0101 properly supported
- Unsubscribe (0103) properly implemented
- Simulated multi-spindle results have realistic data
- Subscription state managed correctly across connection lifecycle
- Handler follows established registry pattern
</success_criteria>

<output>
After completion, create `.planning/phases/05-new-mid-implementation/05-02-SUMMARY.md`
</output>
