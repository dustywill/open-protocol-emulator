---
phase: 01-technical-debt-cleanup
plan: 02
type: execute
depends_on: ["01-01"]
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Add thread synchronization for shared state variables to prevent race conditions.

Purpose: Ensure thread-safe access to state variables shared between TCP server threads and GUI thread.
Output: Thread-safe emulator with RLock protection on shared state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/ARCHITECTURE.md
@.planning/phases/01-technical-debt-cleanup/01-01-SUMMARY.md

@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state lock and protect shared variables</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add thread synchronization for shared state variables that are accessed from multiple threads:
- `session_active` - accessed by server thread, client handler, auto-send loop, GUI
- `tool_enabled` - modified by client handler (MID 0042/0043), read by auto-send loop
- `batch_counter` - modified by tightening result sender, read by GUI
- `auto_send_loop_active` - modified by GUI, read by auto-send loop
- `vin_subscribed`, `result_subscribed`, `pset_subscribed` - modified by client handler, read by auto-send loop
- `current_vin`, `current_pset` - modified by client handler and GUI, read by auto-send loop

**Implementation steps:**

1. Add a `threading.RLock()` for state synchronization in `__init__`:
```python
self.state_lock = threading.RLock()
```
Use RLock (reentrant) rather than Lock because some methods may call other methods that also need the lock.

2. Create property getters/setters for the most frequently accessed shared state that wrap access in the lock. Focus on the critical variables that are written from multiple threads:
```python
@property
def session_active(self):
    with self.state_lock:
        return self._session_active

@session_active.setter
def session_active(self, value):
    with self.state_lock:
        self._session_active = value
```

Apply this pattern to these variables (rename the backing variable with underscore prefix):
- `session_active` → `_session_active`
- `tool_enabled` → `_tool_enabled`
- `auto_send_loop_active` → `_auto_send_loop_active`

3. For variables that are read-modify-write (like `batch_counter`), wrap the entire operation:
```python
with self.state_lock:
    self.batch_counter += 1
    current_count = self.batch_counter
```

4. Initialization in `__init__` should use the backing variables directly:
```python
self._session_active = False
self._tool_enabled = True
self._auto_send_loop_active = True
```

**Locations requiring lock protection:**

- `handle_client()`: when setting `session_active = False`, clearing subscriptions
- `process_message()`: when setting `session_active = True/False`, `tool_enabled`, subscription flags
- `send_single_tightening_result()`: when incrementing `batch_counter`, reading `tool_enabled`
- `send_tightening_results_loop()`: when reading `session_active`, `auto_send_loop_active`
- GUI callbacks: when reading/writing `auto_send_loop_active`, `batch_counter`

Do NOT lock around long operations like socket sends or file I/O - only protect the state variable access itself.
  </action>
  <verify>
Run: `python -c "from open_protocol_emulator import OpenProtocolEmulator; e = OpenProtocolEmulator(); print('session_active:', e.session_active); e.session_active = True; print('session_active:', e.session_active)"`
Should print False then True, demonstrating property access works.
  </verify>
  <done>
- `state_lock` (RLock) added to `__init__`
- Properties with lock protection created for `session_active`, `tool_enabled`, `auto_send_loop_active`
- Critical read-modify-write operations wrapped in lock context
- No deadlocks introduced (RLock is reentrant)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add lock protection to batch counter operations</name>
  <files>open_protocol_emulator.py</files>
  <action>
The `batch_counter` variable is incremented in `send_single_tightening_result()` and reset in `_increment_vin()` and `process_message()` (VIN download), and read in GUI `update_labels()`.

Since increment is a read-modify-write operation, it needs explicit locking even without using properties.

1. Wrap batch_counter increment in `send_single_tightening_result()`:
```python
with self.state_lock:
    if status == "1" and current_target_batch_size > 0:
        self.batch_counter += 1
    batch_counter_val = self.batch_counter
    batch_completed = (batch_counter_val >= current_target_batch_size) if current_target_batch_size > 0 else False
```

2. Wrap batch_counter reset in `_increment_vin()`:
```python
with self.state_lock:
    self.batch_counter = 0
```

3. Wrap batch_counter reset in `process_message()` (MID 0050 VIN download):
```python
with self.state_lock:
    self.batch_counter = 0
```

4. Wrap batch_counter read in GUI `update_labels()`:
```python
with self.state_lock:
    current_batch = self.batch_counter
```

This ensures atomic read-modify-write operations and consistent reads.
  </action>
  <verify>
Run: `python -c "import open_protocol_emulator; print('Import OK')"`
Verify no syntax errors and module loads correctly.
  </verify>
  <done>
- All `batch_counter` modifications wrapped in `state_lock`
- GUI reads use lock to ensure consistent snapshot
- No race conditions possible on batch counter
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "import open_protocol_emulator"` - imports without error
- [ ] `python -c "from open_protocol_emulator import OpenProtocolEmulator; e = OpenProtocolEmulator(); print('Has state_lock:', hasattr(e, 'state_lock'))"` - outputs True
- [ ] Property access works: `python -c "from open_protocol_emulator import OpenProtocolEmulator; e = OpenProtocolEmulator(); e.session_active = True; print(e.session_active)"` - outputs True
- [ ] No deadlocks when starting emulator briefly (manual verification)
</verification>

<success_criteria>

- `state_lock` (RLock) added to class
- Properties with lock protection for `session_active`, `tool_enabled`, `auto_send_loop_active`
- Batch counter operations protected with lock
- Module imports and runs without errors
- No obvious deadlock conditions (RLock used for reentrancy)
</success_criteria>

<output>
After completion, create `.planning/phases/01-technical-debt-cleanup/01-02-SUMMARY.md`
</output>
