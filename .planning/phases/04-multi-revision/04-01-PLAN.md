---
phase: 04-multi-revision
plan: 01
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement multi-revision support for Communication MIDs (0001-0005).

Purpose: Enable proper revision negotiation at session start and enhanced error responses per Open Protocol spec R2.8.0.
Output: MID 0002 supports revisions 1-6, MID 0004 supports revisions 1-3, proper revision negotiation logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-revision/04-RESEARCH.md
@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add revision constants and negotiation helper</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add MAX_REV constants for all MIDs at class level after __init__:
```python
# Maximum supported revision per MID
MAX_REV_0002 = 6   # Communication start acknowledge
MAX_REV_0004 = 3   # Negative acknowledge
MAX_REV_0015 = 2   # Pset selected
MAX_REV_0041 = 5   # Tool data
MAX_REV_0052 = 2   # VIN number
MAX_REV_0061 = 7   # Tightening result
```

Add revision negotiation helper method:
```python
def _get_response_revision(self, mid: int, requested_rev: int) -> int:
    """Return highest supported revision <= requested."""
    max_supported = {
        2: self.MAX_REV_0002,
        4: self.MAX_REV_0004,
        15: self.MAX_REV_0015,
        41: self.MAX_REV_0041,
        52: self.MAX_REV_0052,
        61: self.MAX_REV_0061,
    }
    max_rev = max_supported.get(mid, 1)
    return min(requested_rev, max_rev)
```

Add instance variables for controller info (needed for higher revisions):
```python
self.supplier_code = 1          # Atlas Copco
self.op_version = "2.8.0              "  # 19 chars
self.ctrl_sw_version = "1.0.0              "  # 19 chars
self.tool_sw_version = "1.0.0              "  # 19 chars
self.rbu_type = "                        "  # 24 chars (not used)
self.ctrl_serial = "SN12345678"  # 10 chars
self.system_type = "PF6000    "  # 10 chars
self.system_subtype = "          "  # 10 chars
self.seq_num_support = 0
self.link_support = 0
self.station_id = "0001      "  # 10 chars
self.station_name = "Station               "  # 25 chars
self.client_id = 1
```
  </action>
  <verify>Python syntax check: `python -m py_compile open_protocol_emulator.py` passes</verify>
  <done>Constants defined, helper method added, controller info variables initialized</done>
</task>

<task type="auto">
  <name>Task 2: Implement MID 0002 multi-revision builder</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add method to build MID 0002 response data for any supported revision:
```python
def _build_mid0002_data(self, revision: int) -> str:
    """Build MID 0002 response data for given revision (1-6)."""
    fields = []

    # Revision 1 fields (always included)
    fields.append(f"01{1:04d}")                              # Cell ID
    fields.append(f"02{1:02d}")                              # Channel ID
    fields.append(f"03{self.controller_name}")               # Controller name (25 chars)

    if revision >= 2:
        fields.append(f"04{self.supplier_code:03d}")         # Supplier code
        fields.append(f"05{self.op_version}")                # OP version (19 chars)
        fields.append(f"06{self.ctrl_sw_version}")           # Controller SW (19 chars)
        fields.append(f"07{self.tool_sw_version}")           # Tool SW (19 chars)

    if revision >= 3:
        fields.append(f"08{self.rbu_type}")                  # RBU type (24 chars)
        fields.append(f"09{self.ctrl_serial}")               # Serial (10 chars)

    if revision >= 4:
        fields.append(f"10{self.system_type}")               # System type (10 chars)
        fields.append(f"11{self.system_subtype}")            # Subtype (10 chars)

    if revision >= 5:
        fields.append(f"12{self.seq_num_support:01d}")       # Seq num support
        fields.append(f"13{self.link_support:01d}")          # Link support
        fields.append(f"14{self.station_id}")                # Station ID (10 chars)
        fields.append(f"15{self.station_name}")              # Station name (25 chars)

    if revision >= 6:
        fields.append(f"16{self.client_id:01d}")             # Client ID

    return "".join(fields)
```

Update MID 0001 handler in process_message() to use revision negotiation:
- Remove the `if requested_rev > 1: resp = build_message(4, rev=1, data="000197")` rejection
- Calculate response_rev = self._get_response_revision(2, requested_rev)
- Build response with `data = self._build_mid0002_data(response_rev)`
- Send response with `build_message(2, rev=response_rev, data=data)`
  </action>
  <verify>Run emulator, connect with client requesting rev 1, 2, 3, 6 - all should get successful response with correct revision</verify>
  <done>MID 0002 responses correctly formatted for revisions 1-6 based on request</done>
</task>

<task type="auto">
  <name>Task 3: Implement MID 0004 multi-revision error response</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add method to build MID 0004 response data for any supported revision:
```python
def _build_mid0004_data(self, revision: int, mid: int, error_code: int, extra_text: str = "") -> str:
    """Build MID 0004 error response data for given revision (1-3)."""
    fields = []

    # Revision 1: MID (4 digits) + Error code (2 digits)
    fields.append(f"{mid:04d}")
    fields.append(f"{error_code:02d}")

    if revision >= 2:
        # Revision 2 adds: Error MID (the MID that caused error)
        fields.append(f"{mid:04d}")  # Error MID repeated

    if revision >= 3:
        # Revision 3 adds: Extra info text (25 chars)
        fields.append(f"{extra_text.ljust(25)[:25]}")

    return "".join(fields)
```

Update all locations that send MID 0004 to track the requesting MID revision and use appropriate error response revision. Key locations to update:
- MID 0018 errors (pset not found)
- MID 0014 errors (already subscribed)
- MID 0051 errors (revision unsupported, already subscribed)
- MID 0054 errors (not subscribed)
- MID 0060 errors (revision unsupported, already subscribed)
- MID 0063 errors (not subscribed)
- Unknown MID errors

For each error, determine the appropriate MID 0004 revision based on what the client supports (use rev 1 as default since we don't track client capability).
  </action>
  <verify>Send invalid request (e.g., subscribe when already subscribed), verify MID 0004 response has correct format</verify>
  <done>MID 0004 error responses use revision-aware formatting</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile open_protocol_emulator.py` passes
- [ ] Emulator starts without errors
- [ ] MID 0001 with rev=1 returns MID 0002 rev 1 with 3 fields
- [ ] MID 0001 with rev=3 returns MID 0002 rev 3 with additional fields
- [ ] MID 0001 with rev=6 returns MID 0002 rev 6 with all fields
- [ ] MID 0001 with rev=99 returns MID 0002 rev 6 (negotiated down)
- [ ] Error conditions still return proper MID 0004
</verification>

<success_criteria>
- All tasks completed
- Revision negotiation works correctly
- MID 0002 response format matches spec for all revisions 1-6
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-revision/04-01-SUMMARY.md`
</output>
