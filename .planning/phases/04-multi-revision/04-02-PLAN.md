---
phase: 04-multi-revision
plan: 02
type: execute
depends_on: ["04-01"]
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement multi-revision support for Parameter Set MIDs (0014-0018).

Purpose: Enable MID 0015 revision 2 which adds batch size, batch counter, and OK counter fields.
Output: MID 0015 supports revisions 1-2 with proper field content.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-revision/04-RESEARCH.md
@.planning/phases/04-multi-revision/04-01-SUMMARY.md
@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Track subscription revision for Pset</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add instance variable to track the revision the client subscribed with:
```python
self.pset_subscribed_rev = 1  # Revision requested in MID 0014
```

Update MID 0014 handler to:
1. Parse requested revision from the message header
2. Use revision negotiation: `subscribed_rev = self._get_response_revision(15, requested_rev)`
3. Store the negotiated revision: `self.pset_subscribed_rev = subscribed_rev`
4. The acceptance response (MID 0005) stays at rev 1 (it only has rev 1)

Note: MID 0014 only has revision 1, but it controls which revision of MID 0015 is sent.
  </action>
  <verify>Python syntax check passes</verify>
  <done>Pset subscription revision tracking implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement MID 0015 multi-revision builder</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add instance variable to track OK counter (needed for rev 2):
```python
self.pset_ok_counter = 0  # Count of OK tightenings since Pset selected
```

Add method to build MID 0015 response data:
```python
def _build_mid0015_data(self, revision: int) -> str:
    """Build MID 0015 Pset selected data for given revision (1-2)."""
    pset_id = (self.current_pset if self.current_pset else "0").rjust(3, '0')

    if revision == 1:
        # Revision 1: Just the Pset ID (3 digits)
        return pset_id

    elif revision >= 2:
        # Revision 2: Pset ID + batch size + batch counter + OK counter
        pset_params = self.pset_parameters.get(self.current_pset, {})
        batch_size = pset_params.get("batch_size", self.target_batch_size)
        with self.state_lock:
            batch_counter = self.batch_counter
            ok_counter = self.pset_ok_counter

        fields = []
        fields.append(f"01{pset_id}")                    # Pset ID (3 digits)
        fields.append(f"02{batch_size:04d}")             # Batch size (4 digits)
        fields.append(f"03{batch_counter:04d}")          # Batch counter (4 digits)
        fields.append(f"04{ok_counter:04d}")             # OK counter (4 digits)
        return "".join(fields)

    return pset_id  # Fallback to rev 1
```

Update MID 0018 handler (Select Pset) to reset OK counter when Pset changes:
```python
self.pset_ok_counter = 0  # Reset OK counter on Pset change
```

Update send_single_tightening_result() to increment OK counter on successful tightening:
```python
if status == "1":  # OK result
    self.pset_ok_counter += 1
```
  </action>
  <verify>Python syntax check passes</verify>
  <done>MID 0015 builder method implemented with rev 1 and 2 support</done>
</task>

<task type="auto">
  <name>Task 3: Update all MID 0015 send locations</name>
  <files>open_protocol_emulator.py</files>
  <action>
Find and update all places that send MID 0015 to use the builder and subscribed revision:

1. In MID 0018 handler (after Pset selection):
```python
if self.pset_subscribed:
    mid15_data = self._build_mid0015_data(self.pset_subscribed_rev)
    mid15_msg = build_message(15, rev=self.pset_subscribed_rev, data=mid15_data)
    self.send_to_client(mid15_msg)
```

2. In MID 0014 handler (initial subscription response):
```python
if self.current_pset:
    mid15_data = self._build_mid0015_data(self.pset_subscribed_rev)
    mid15_msg = build_message(15, rev=self.pset_subscribed_rev, data=mid15_data)
    self.send_to_client(mid15_msg)
```

Also reset pset_subscribed_rev when unsubscribing (MID 0017 if implemented) or on disconnect.
In handle_client cleanup section:
```python
self.pset_subscribed_rev = 1  # Reset to default
```
  </action>
  <verify>Start emulator, subscribe to Pset with rev 2, select a Pset, verify MID 0015 contains batch fields</verify>
  <done>All MID 0015 sends use proper revision-aware formatting</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile open_protocol_emulator.py` passes
- [ ] Emulator starts without errors
- [ ] MID 0014 with rev=1 → MID 0015 rev 1 with just Pset ID (3 digits)
- [ ] MID 0014 with rev=2 → MID 0015 rev 2 with Pset ID + batch size + counters
- [ ] Pset change triggers MID 0015 with correct revision
- [ ] OK counter increments on successful tightenings
- [ ] Counters reset appropriately on Pset change
</verification>

<success_criteria>
- All tasks completed
- MID 0015 responds with correct revision based on subscription
- OK counter tracking works correctly
- No regressions in Pset selection functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-revision/04-02-SUMMARY.md`
</output>
