---
phase: 04-multi-revision
plan: 05
type: execute
depends_on: ["04-01"]
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement multi-revision support for Tightening Result MIDs (0060-0063).

Purpose: Enable MID 0061 revisions 1-7 which add strategy data, tightening error status 2, and stage result information per Open Protocol spec R2.8.0.
Output: MID 0061 supports revisions 1-7 with proper field content based on subscription request.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-revision/04-RESEARCH.md
@.planning/phases/04-multi-revision/04-01-SUMMARY.md
@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tightening result extended data and subscription tracking</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add instance variables for extended tightening data (revisions 3-7):
```python
# Extended tightening result data (for MID 0061 rev 3+)
self.strategy_code = 0               # 4 digits, 0 = N/A
self.strategy_options = "0" * 5      # 5 binary flags (rev 4)
self.tightening_error_status_2 = 0   # 10 digits (rev 5)
self.stage_result_count = 0          # 2 digits (rev 6)
# Stage results (rev 7) would be dynamic based on stage_result_count
# For simplicity, we'll simulate 0 stages initially

# Result subscription revision tracking
self.result_subscribed_rev = 1  # Revision requested in MID 0060
```

Reset result_subscribed_rev on disconnect in handle_client cleanup:
```python
self.result_subscribed_rev = 1  # Reset to default
```
  </action>
  <verify>Python syntax check passes</verify>
  <done>Extended tightening data variables and subscription tracking added</done>
</task>

<task type="auto">
  <name>Task 2: Implement MID 0061 multi-revision builder</name>
  <files>open_protocol_emulator.py</files>
  <action>
Refactor send_single_tightening_result() to use a builder method. Create:
```python
def _build_mid0061_data(self, revision: int, result_params: dict) -> str:
    """Build MID 0061 tightening result data for given revision (1-7).

    Args:
        revision: Requested revision (1-7)
        result_params: Dict with all tightening result values
    """
    fields = []

    # Revision 1/2 fields (23 fields - rev 2 is structurally same as rev 1)
    fields.append(f"01{result_params['cell_id']:04d}")
    fields.append(f"02{result_params['channel_id']:02d}")
    fields.append(f"03{result_params['controller_name']}")       # 25 chars
    fields.append(f"04{result_params['vin']}")                   # 25 chars
    fields.append(f"05{result_params['job_id']:02d}")
    fields.append(f"06{result_params['pset_id']}")               # 3 chars
    fields.append(f"07{result_params['batch_size']:04d}")
    fields.append(f"08{result_params['batch_counter']:04d}")
    fields.append(f"09{result_params['status']}")                # 1 char
    fields.append(f"10{result_params['torque_status']}")         # 1 char
    fields.append(f"11{result_params['angle_status']}")          # 1 char
    fields.append(f"12{result_params['torque_min']:06d}")        # x100
    fields.append(f"13{result_params['torque_max']:06d}")        # x100
    fields.append(f"14{result_params['torque_target']:06d}")     # x100
    fields.append(f"15{result_params['torque_final']:06d}")      # x100
    fields.append(f"16{result_params['angle_min']:05d}")
    fields.append(f"17{result_params['angle_max']:05d}")
    fields.append(f"18{result_params['angle_target']:05d}")
    fields.append(f"19{result_params['angle_final']:05d}")
    fields.append(f"20{result_params['timestamp']}")             # 19 chars
    fields.append(f"21{result_params['pset_change_time']}")      # 19 chars
    fields.append(f"22{result_params['batch_status']}")          # 1 char
    fields.append(f"23{result_params['tightening_id']:010d}")

    if revision >= 3:
        fields.append(f"24{self.strategy_code:04d}")             # Strategy code

    if revision >= 4:
        fields.append(f"25{self.strategy_options}")              # Strategy options (5 chars)

    if revision >= 5:
        fields.append(f"26{self.tightening_error_status_2:010d}")  # Error status 2

    if revision >= 6:
        fields.append(f"27{self.stage_result_count:02d}")        # Stage count

    if revision >= 7:
        # Stage results - each stage would add multiple fields
        # For now, with stage_result_count = 0, no additional fields
        pass

    return "".join(fields)
```
  </action>
  <verify>Python syntax check passes</verify>
  <done>MID 0061 builder method implemented for revisions 1-7</done>
</task>

<task type="auto">
  <name>Task 3: Update result handlers to use revision-aware formatting</name>
  <files>open_protocol_emulator.py</files>
  <action>
Update MID 0060 handler (Result subscribe) to:
1. Remove the revision rejection: `if req_rev > 1: resp = build_message(4, ...)`
2. Use revision negotiation: `subscribed_rev = self._get_response_revision(61, req_rev)`
3. Store the negotiated revision: `self.result_subscribed_rev = subscribed_rev`
4. Log the subscribed revision: `print(f"[Tightening] Subscribed at revision {subscribed_rev}")`

Refactor send_single_tightening_result() to:
1. Build the result_params dict with all current values (keep existing logic for generating torque/angle/status)
2. Call `data = self._build_mid0061_data(self.result_subscribed_rev, result_params)`
3. Send with `build_message(61, rev=self.result_subscribed_rev, data=data, no_ack=self.result_no_ack)`

The result_params dict should be built from existing variables:
```python
result_params = {
    'cell_id': 1,
    'channel_id': 1,
    'controller_name': self.controller_name,
    'vin': self.current_vin.ljust(25),
    'job_id': 0,
    'pset_id': (self.current_pset if self.current_pset else "0").rjust(3, '0'),
    'batch_size': current_target_batch_size,
    'batch_counter': batch_counter_val,
    'status': status,
    'torque_status': torque_status,
    'angle_status': angle_status,
    'torque_min': int(torque_min * 100),
    'torque_max': int(torque_max * 100),
    'torque_target': int(target_torque * 100),
    'torque_final': int(actual_torque * 100),
    'angle_min': int(angle_min),
    'angle_max': int(angle_max),
    'angle_target': int(target_angle),
    'angle_final': int(actual_angle),
    'timestamp': timestamp_str,
    'pset_change_time': pset_change_ts,
    'batch_status': batch_status,
    'tightening_id': self.tightening_id_counter,
}
```
  </action>
  <verify>Subscribe with rev 1, 3, 5, 7 and verify MID 0061 format has correct field count</verify>
  <done>All tightening result sends use proper revision-aware formatting</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile open_protocol_emulator.py` passes
- [ ] Emulator starts without errors
- [ ] MID 0060 with rev=1 → MID 0061 rev 1 with 23 fields
- [ ] MID 0060 with rev=3 → MID 0061 rev 3 with 24 fields (includes strategy code)
- [ ] MID 0060 with rev=5 → MID 0061 rev 5 with 26 fields (includes error status 2)
- [ ] MID 0060 with rev=7 → MID 0061 rev 7 with 27+ fields
- [ ] MID 0060 with rev=99 → MID 0061 rev 7 (negotiated down to max supported)
- [ ] Tightening results contain correct values for all fields
- [ ] No regressions in auto-send loop or manual send
</verification>

<success_criteria>
- All tasks completed
- MID 0061 responds with correct revision based on subscription
- All revision-specific fields populated correctly
- No regressions in tightening result functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-revision/04-05-SUMMARY.md`
</output>
