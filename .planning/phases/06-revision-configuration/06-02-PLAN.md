---
phase: 06-revision-configuration
plan: 02
type: execute
depends_on: ["06-01"]
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement controller profiles system with preset revision configurations.

Purpose: Allow users to quickly switch between predefined controller configurations that match real PF6000 firmware versions, rather than manually setting each MID revision.
Output: Profile management system with built-in presets and JSON save/load capability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-revision-configuration/06-01-SUMMARY.md
@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define built-in controller profiles</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add a class-level constant `DEFAULT_PROFILES` containing predefined controller configurations. Place this after the class definition line (after `class OpenProtocolEmulator:`):

```python
DEFAULT_PROFILES = {
    "legacy": {
        "description": "Legacy mode - revision 1 only for all MIDs",
        "revisions": {
            2: 1, 4: 1, 15: 1, 41: 1, 52: 1, 61: 1
        }
    },
    "pf6000-basic": {
        "description": "PF6000 basic - moderate revision support",
        "revisions": {
            2: 3, 4: 2, 15: 1, 41: 2, 52: 1, 61: 2
        }
    },
    "pf6000-full": {
        "description": "PF6000 full - maximum revision support",
        "revisions": {
            2: 6, 4: 3, 15: 2, 41: 5, 52: 2, 61: 7
        }
    }
}
```

Also add an instance variable in `__init__()` to track the current profile:

```python
self.current_profile = "pf6000-full"  # Default profile name
```

Place this after the revision_config initialization from Plan 06-01.
  </action>
  <verify>Python syntax check: `python -m py_compile open_protocol_emulator.py`</verify>
  <done>DEFAULT_PROFILES class constant exists with 3 profiles, current_profile instance variable initialized</done>
</task>

<task type="auto">
  <name>Task 2: Implement profile application and management methods</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add profile management methods after the revision getter/setter methods from Plan 06-01:

```python
def apply_profile(self, profile_name: str) -> None:
    """Apply a controller profile by name."""
    if profile_name not in self.DEFAULT_PROFILES:
        raise ValueError(f"Unknown profile: {profile_name}. Available: {list(self.DEFAULT_PROFILES.keys())}")

    profile = self.DEFAULT_PROFILES[profile_name]
    self.revision_config.update(profile["revisions"])
    self.current_profile = profile_name

def get_current_profile(self) -> str:
    """Get the name of the currently active profile."""
    return self.current_profile

def get_available_profiles(self) -> list:
    """Get list of available profile names."""
    return list(self.DEFAULT_PROFILES.keys())

def get_profile_description(self, profile_name: str) -> str:
    """Get the description of a profile."""
    if profile_name not in self.DEFAULT_PROFILES:
        return "Unknown profile"
    return self.DEFAULT_PROFILES[profile_name]["description"]
```

These methods allow the GUI (Phase 7) to:
- List available profiles for a dropdown
- Apply a selected profile
- Display profile descriptions
  </action>
  <verify>
1. Python syntax check: `python -m py_compile open_protocol_emulator.py`
2. Verify methods exist by searching for "def apply_profile"
  </verify>
  <done>Four profile methods added: apply_profile, get_current_profile, get_available_profiles, get_profile_description</done>
</task>

<task type="auto">
  <name>Task 3: Implement profile save/load to JSON</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add JSON persistence methods for saving and loading custom profiles. Place after the profile management methods:

```python
def save_profile_to_file(self, filepath: str, profile_name: str) -> None:
    """Save current revision config as a named profile to JSON file."""
    import json
    profile_data = {
        "name": profile_name,
        "description": f"Custom profile: {profile_name}",
        "revisions": dict(self.revision_config)
    }
    with open(filepath, 'w') as f:
        json.dump(profile_data, f, indent=2)

def load_profile_from_file(self, filepath: str) -> str:
    """Load a profile from JSON file and apply it. Returns profile name."""
    import json
    import os
    if not os.path.exists(filepath):
        raise FileNotFoundError(f"Profile file not found: {filepath}")

    with open(filepath, 'r') as f:
        profile_data = json.load(f)

    if "revisions" not in profile_data:
        raise ValueError("Invalid profile file: missing 'revisions' key")

    for mid_str, rev in profile_data["revisions"].items():
        mid = int(mid_str)
        self.revision_config[mid] = rev

    profile_name = profile_data.get("name", "custom")
    self.current_profile = profile_name
    return profile_name
```

Note: import json inside methods to keep it localized (matches existing pattern in `_load_pset_parameters`). The existing codebase already uses json for pset parameter persistence.
  </action>
  <verify>
1. Python syntax check: `python -m py_compile open_protocol_emulator.py`
2. Verify methods exist by searching for "def save_profile_to_file"
  </verify>
  <done>save_profile_to_file and load_profile_from_file methods added with JSON persistence</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile open_protocol_emulator.py` passes
- [ ] DEFAULT_PROFILES constant exists with 3 profiles (legacy, pf6000-basic, pf6000-full)
- [ ] current_profile instance variable initialized
- [ ] Profile methods exist: apply_profile, get_current_profile, get_available_profiles, get_profile_description
- [ ] JSON methods exist: save_profile_to_file, load_profile_from_file
- [ ] Emulator starts without errors: `python open_protocol_emulator.py --help`
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Profiles can be applied at runtime
- Profiles can be saved/loaded from JSON files
- Ready for GUI integration in Phase 7
</success_criteria>

<output>
After completion, create `.planning/phases/06-revision-configuration/06-02-SUMMARY.md`
</output>
