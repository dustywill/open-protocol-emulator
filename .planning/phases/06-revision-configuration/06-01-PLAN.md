---
phase: 06-revision-configuration
plan: 01
type: execute
depends_on: []
files_modified: [open_protocol_emulator.py]
autonomous: true
---

<objective>
Implement per-MID revision configuration system to replace hardcoded MAX_REV constants.

Purpose: Enable runtime configuration of maximum supported revision per MID, allowing the emulator to simulate different controller firmware versions and capabilities.
Output: Configurable revision limits that can be adjusted without code changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.5-architecture-refactor/03.5-01-SUMMARY.md
@.planning/phases/04-multi-revision/04-RESEARCH.md
@open_protocol_emulator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create revision configuration data structure</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add a `revision_config` dictionary instance variable in `__init__()` that maps MID numbers to their maximum supported revision. Initialize with current hardcoded values:

```python
self.revision_config = {
    2: 6,     # MID 0002 - Communication start ack
    4: 3,     # MID 0004 - Communication negative ack
    15: 2,    # MID 0015 - Pset selected
    41: 5,    # MID 0041 - Tool data reply
    52: 2,    # MID 0052 - VIN number
    61: 7,    # MID 0061 - Tightening result
    101: 5,   # MID 0101 - Multi-spindle result
    215: 2,   # MID 0215 - I/O device status reply
}
```

Add this after the existing state variables initialization section (after the relay_subscriptions initialization). Include a comment block explaining the purpose of the configuration.

Do NOT remove the existing MAX_REV class constants yet - that's Task 2.
  </action>
  <verify>Python syntax check: `python -m py_compile open_protocol_emulator.py`</verify>
  <done>revision_config dictionary exists in __init__ with all 8 MID entries</done>
</task>

<task type="auto">
  <name>Task 2: Refactor _get_response_revision to use configuration</name>
  <files>open_protocol_emulator.py</files>
  <action>
Modify `_get_response_revision()` method (around line 165) to use `self.revision_config` instead of the hardcoded dictionary. The method currently has:

```python
max_supported = {
    2: self.MAX_REV_0002,
    4: self.MAX_REV_0004,
    ...
}
```

Change to:

```python
max_supported = self.revision_config.get(mid, 1)
return min(requested_rev, max_supported)
```

This simplifies the method since revision_config already has the MIDâ†’revision mapping.

After verifying this works, remove the class-level MAX_REV_XXXX constants (lines 37-44, all 8 of them) since they are no longer needed. The configuration now lives in the instance variable.

Also update `_handle_mid_0100` and `_handle_mid_0214` handlers to use the unified revision checking:
- Replace `if req_rev > self.MAX_REV_0101:` with `if req_rev > self.revision_config.get(101, 1):`
- Replace `if req_rev > self.MAX_REV_0215:` with `if req_rev > self.revision_config.get(215, 1):`
  </action>
  <verify>
1. Python syntax check: `python -m py_compile open_protocol_emulator.py`
2. Verify MAX_REV constants are removed and _get_response_revision uses revision_config
  </verify>
  <done>_get_response_revision uses self.revision_config, MAX_REV constants removed</done>
</task>

<task type="auto">
  <name>Task 3: Add revision configuration getter/setter methods</name>
  <files>open_protocol_emulator.py</files>
  <action>
Add three public methods for revision configuration management. Place these after _get_response_revision() method:

```python
def get_max_revision(self, mid: int) -> int:
    """Get the maximum supported revision for a MID."""
    return self.revision_config.get(mid, 1)

def set_max_revision(self, mid: int, max_rev: int) -> None:
    """Set the maximum supported revision for a MID."""
    if max_rev < 1:
        raise ValueError(f"Revision must be >= 1, got {max_rev}")
    self.revision_config[mid] = max_rev

def get_all_revision_config(self) -> dict:
    """Get a copy of the full revision configuration."""
    return dict(self.revision_config)
```

These methods enable:
- GUI controls to read/write revision settings
- Profile system (Plan 06-02) to apply bulk configuration
- Runtime revision changes without restart
  </action>
  <verify>
1. Python syntax check: `python -m py_compile open_protocol_emulator.py`
2. Verify methods exist: search for "def get_max_revision" in file
  </verify>
  <done>Three revision management methods added: get_max_revision, set_max_revision, get_all_revision_config</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile open_protocol_emulator.py` passes
- [ ] revision_config dictionary exists with all 8 MID entries (2, 4, 15, 41, 52, 61, 101, 215)
- [ ] MAX_REV_XXXX class constants are removed (all 8)
- [ ] _get_response_revision uses self.revision_config
- [ ] _handle_mid_0100 and _handle_mid_0214 use revision_config instead of MAX_REV constants
- [ ] get_max_revision, set_max_revision, get_all_revision_config methods exist
- [ ] Emulator starts without errors: `python open_protocol_emulator.py --help`
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Revision configuration is runtime-modifiable
- Existing behavior unchanged (same default revision limits)
</success_criteria>

<output>
After completion, create `.planning/phases/06-revision-configuration/06-01-SUMMARY.md`
</output>
